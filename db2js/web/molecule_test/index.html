<!DOCTYPE html>
<html>
<head>
<title>molecule samples</title>
<meta charset="utf-8">
</head>
<body>
	<h1>最简单的 molecule</h1>
	<a href="0.html">点击</a>
	这个分子定义于页面内部，Molecule 会自动将定义提出，并删除定义元素。
	<ol>
		<li>molecule 使用 molecule-def="分子名" module="包名"　depends="依赖包,依赖包,..." 定义，任何 html 元素都可以变为 molecule</li>
		<li>molecule 定义中结尾总是调用 Molecule.create(Function, document.currentScript) 函数，完成 js 和元素间的绑定，使其变为有生命的分子</li>
		<li>能动函数总是用 if(typeof Function == 'undefined') 判断是否已经定义过了</li>
		<li>molecule 实例只要使用 molecule="包名.分子名" 即可创建</li>
		<li>molecule 实例创建不需要再执行任何脚本，创建新 html元素时，append 后即生效</li>
		<li>可以通过 Molecule.of(html element) 获取实例的 js 对象</li>
		<li>molecule 在实例化后，其对象总是派生自 Molecule类，获得该类的方法</li>
		<li>当 molecule 实例的 html 元素删除时，该对象即自动销毁</li>
		<li>在设计molecule时，可设置 Molecule.TEST_DEFINE = true; 避免被销毁</li>
		<li>可以重载 dispose 函数 this.dispose= function(){} 进行收尾工作</li>
		<li>molecule 实例的 html 元素，可以设置自己的 innerHTML，这段 html 会追加到 molecule 模板 html 末尾</li>
		<li>molecule 实例自定义的 html attribute，在实例化后仍然保留, 通过以上两项可以进行一定意义上的重载</li>
		<li>在 molecule 定义中夹杂 css 脚本，可以使脚本、html元素、能动函数混为一体</li>
		<li>molecule 能动函数可以通过 this.container 访问html元素</li>
		<li>实例的 html 元素可以通过设置 data-param1="" data-param2="" data-option="json" 提供初始化参数，实现参数化</li>
		<li>实例显然也可以重载 css 样式表，因为实例自身的 css 样式表总是能覆盖模板的样式表，但是这种覆盖也会影响其它实例，自己想想办法(见下例)</li>
		<li>实例可以嵌套入其它 molecule，形成更大元素，这种元素可以加上 molecule-def 导出为新的大分子，也就是说分子可以聚合为更大的分子</li>
		<li>不要在实例函数中定义公用通用函数，这些函数不实例化是不会调用的，应将它们定义于额外的文件中</li>
	</ol>
	
	<h1>俄罗斯方块</h1>
	<p>
	<a href="../molecules/blocks.html">原始页面</a>
	</p>
	经过执行 molecules/extract.jssp 后，该原始页面抽取为 模块名.json，存放于 molecules/ 目录。
	<p>
	<a href="1.html">进入</a>
	</p>
</body>
</html>